[{"title":"H5移动端适配方案","url":"/2018/12/16/H5移动端适配方案/","content":"\n## 准备工作\n\n### viewport\n\n`viewport` 指的是浏览器可视化的区域，即 `window.innerWidth`和 `window.innerHeight`的大小\n\ncss3 中与 `viewport` 相关的单位：\n\n* `vw`: 是 viewport's width 的简写，1vw 等于 `window.innerWidth` 的1%\n* `vh`: 是 viewport's height 的简写，1vh 等于 `window.innerHeight` 的1%\n* `vmin`: `vmin` 是当前 `vw` 和 `vh` 中较小的值\n* `vmax`: `vmax` 是当前 `vw` 和 `vh` 中较大的值 \n\n如图：\n\n![](/img/viewport.png)\n\n`viewport` 支持情况：\n\n![](/img/support.png)\n\n## 适配方案\n\n简单来说就是将 `px` 转换为 `vw`，用 `vw` 作为基础单位进行布局，达到在不同移动设备上界面表现一直的效果。如果设计稿使用 `750px` 的宽度，那么 `100vw = 750px`，即 `1vw = 7.5px`。根据这个关系即可将设计图上的 `px` 转换为 `vw` 值，所幸这个计算工作有插件 `postcss-px-to-viewport` 帮我们完成，实际操作中我只需严格按照设计图直接在代码中写 `px` 即可。\n\n## 实战：如何在Vue项目中使用vw实现适配\n\n1. 使用 `Vue-cli` 构建项目\n\n\t\tvue init webpack my-project\n\t\t\n2. 安装PostCSS插件\n\n\t使用 `Vue-cli` 构建的项目，在项目根目录下有一个 `.postcssrc.js` 文件，默认会包含三个插件：\n\t\n\t\tmodule.exports = {\n\t\t\t\"plugins\": {\n\t\t\t\t\"postcss-import\": {},\n\t\t\t\t\"postcss-url\": {},\n\t\t\t\t\"autoprefixer\": {}\n\t\t\t}\n\t\t}\n\t\t\n\t**postcss-import**\n\t\n\t`postcss-import` 主要功能是解决 `@import` 引入路径问题。\n\t\n\t**postcss-url**\n\t\n\t`postcss-url` 主要用来处理文件，比如图片文件、字体文件等引用路径的处理。\n\t\n\t**autoprefixer**\n\t\n\t`autoprefixer` 主要用来自动处理浏览器前缀的问题。\n\n\t**实现 `vw` 布局兼容方案需增加以下插件：**\n\t\n\t**postcss-px-to-viewport**\n\t\n\t`postcss-px-to-viewport` 主要用来将 `px` 单位转换为 `vw` 、`vh`、 `vmin` 或者 `vmax` 这些 `viewport` 单位\n\t\n\t\tnpm i postcss-px-to-viewport\n\t\n\t**postcss-aspect-ratio-mini**\n\t\n\t`postcss-aspect-ratio-mini` 主要用来处理元素容器宽高比。\n\t\n\t\tnpm i postcss-aspect-ratio-mini\n\t\t\n\t**postcss-cssnext**\n\t\n\t`postcss-cssnext` 可以让我们使用CSS未来的特性，插件会对这些特性做相关的兼容性处理。\n\t\n\t\tnpm i postcss-cssnext\n\t\t\n\t**cssnano**\n\t\n\t`cssnano` 主要用来压缩和清理CSS代码。在 `webpack` 中， `cssnano` 和 `css-loader`捆绑在一起，所以不需要自己加载它。可以使用 `postcss-loader` 显示的使用 `cssnano`。\n\t\n\t**postcss-write-svg**\n\t\n\t`postcss-write-svg` 主要用来处理移动端 `1px` 的解决方案，主要使用 `border-image` 和 `background` 来做 `1px` 的相关处理。比如：\n\t\n\t\t@svg 1px-border {\n\t\t\theight: 2px;\n\t\t\t@rect {\n\t\t\t\tfill: var(--color, black);\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 50%;\n\t\t\t}\n\t\t}\n\t\t.example {\n\t\t\tborder: 1px solid transparent;\n\t\t\tborder-img: svg(1px-border param(--color #00b1ff)) 2 2 stretch;\n\t\t}\n\t\t\n\t安装\n\t\n\t\tnpm i postcss-write-svg\n\t\t\n\t**postcss-viewport-units**\n\t\n\t`postcss-viewport-units` 主要用来给CSS属性添加 `content` 属性，配合 `viewport-units-buggyfill` 库给 `vw`、`vh`、`vmin`、`vmax`做适配的操作。这是 `vw` 布局必不可少的一个插件。\n\t\n\t\tnpm i postcss-viewport-units\n\t\t\n\t\t\n3. `.postcssrc.js` 文件中配置插件\n\n\t\tmodule.exports = {\n\t\t\t\"plugins\": {\n\t\t\t\t\"postcss-import\": {},\n\t\t\t\t\"postcss-url\": {},\n\t\t\t\t\"autoprefixer\": {}\n\t\t\t\t\"postcss-aspect-ratio-mini\": {},\n    \t\t\t\"postcss-write-svg\": {\n    \t\t\t\tutf8: false\n    \t\t\t},\n    \t\t\t\"postcss-cssnext\": {},\n    \t\t\t\"postcss-px-to-viewport\": {\n    \t\t\t\tviewportWidth: 375, // 视窗的宽度，对应设计稿的宽度\n    \t\t\t\tviewportHeight: 1334, // 视窗高度，可不配置\n    \t\t\t\tunitPrecision: 5, // 指定 'px' 转换为视窗单位值的小数位数\n    \t\t\t\tviewportUnit: 'vw', // 指定需要转换成的视窗单位\n    \t\t\t\tselectorBlackList: ['.ignore'], // 指定不转换为视窗单位的类，可自定义，可无限添加\n    \t\t\t\tminPixelValue: 1, // 小于或等于 '1px' 不转换为视窗单位\n    \t\t\t\tmediaQuery: false // 是否允许媒体查询中转换 'px'\n    \t\t\t\t},\n    \t\t\t\"postcss-viewport-units\": {},\n    \t\t\t\"cssnano\": {\n    \t\t\t\tpreset: \"advanced\",\n    \t\t\t\tautoprefixer: false,\n    \t\t\t\t\"postcss-zindex\": false\n    \t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t在 `cssnano` 的配置中，使用了preset: \"advanced\"，所以我们需要另外安装：\n\t\n\t\tnpm i cssnano-preset-advanced --save-dev\n\t\t\n\t\t\n\t只要启用了`cssnano`这个插件，`z-index`的值就会重置为1。**切记**将`postcss-zindex`设置为false。\n\t\n\t\n\t`postcss-px-to-viewport` 中配置了 `selectorBlackList`，在不想把 `px` 转换为 `vw` 的时候，可以将 `px` 写在 `selectorBlackList ` 中定义的某个方法中，然后将改方法应用的对应的 `html` 元素上，如下：\n\t\n\t\t// html\n\t\t<div calss=\"box ignore\"></div>\n\t\t\n\t\t// css\n\t\t.box {\n\t\t\twidth: 180px;\n\t\t\theight: 300px;\n\t\t}\n\t\t.ignore {\n\t\t\tmargin: 10px;\n\t\t}\n\t\t\n\t\t\n\t\t// 编译后的CSS\n\t\t\n\t\t.box {\n\t\t\twidth: 24vw;\n\t\t\theight: 40vw;\n\t\t}\n\t\t.ignore {\n\t\t\tmargin: 10px; // 这个类名中写的`px`不会被转换\n\t\t}\n\t\t\n\t\t\n\t\t\n4. 大功告成，按照设计稿写 `px` 即可完成适配工作。","tags":["Vue"]},{"title":"Swift Sequence（一）","url":"/2018/12/02/SwiftSequence/","content":"\n`Sequence` 协议是集合类型的基础，可以通过实现 `Sequence` 协议来实现一个自定义的序列类型。满足 `Sequence` 协议的要求十分简单，只需要提供一个返回**迭代器**(Iterator)的 `makeIterator()` 方法：\n\n```\nprotocol Sequence {\n\tassociatetype Iterator: IteratorProtocol\n\tfunc makeIterator() -> Iterator\n\t// ...\n}\n```\n\n\n## IteratorProtocol\n\n序列通过创建一个迭代器来访问元素，迭代器每次产生一个序列的值，并且当遍历序列时对遍历状态进行管理。在 `IteratorProtocol` 协议中唯一的一个方法是 `next()`, 每次调用返回序列的下一个值，当到达序列末尾时返回 `nil`:\n\n```\nprotocol IteratorProtocol {\n\tassociatetype Element\n\tmutating func next() -> Element?\n}\n```\n\n遍历序列最常用、最简单的方式就是 for 循环，从本质上来说，for 循环是下面这种形式的简写:\n\n```\nvar iterator = someSequence.makeIterator()\n\twhile let element = iteraotr.next() {\n\t// do something...\n}\n```\n\t\n### 自定义一个裴波那契序列：\n\n```\nstruct FibsIterator: IteratorProtocol {\n    var state = (0, 1)\n    \n    mutating func next() -> Int? {\n        let upcomingNumber = state.0\n        state = (state.1, state.0 + state.1)\n        return upcomingNumber\n    }\n}\n\nstruct FibsSequence: Sequence {\n    func makeIterator() -> FibsIterator {\n        return FibsIterator()\n    }\n}\n\nlet fibs = FibsSequence()\nfor num in fibs.prefix(10) {\n    print(num)\n}\n/*\n 0\n 1\n 1\n 2\n 3\n 5\n 8\n 13\n 21\n 34\n*/\n\n```\n\n### 迭代器的值语义\n\n`FibsIterator` 迭代器具有值语义，即如果复制一份迭代器，迭代器的所有状态也会被复制，标准库中的大部分迭代器都具有值语义。\n\n```\nvar i1 = FibsIterator(upRangeBound: 20)\ni1.next() // 0\ni1.next() // 1\nvar i2 = iterator\ni1.next() // 1\ni2.next() // 2\ni2.next() // 1\ni2.next() // 2\n```\n\n\n要创建一个不具有值语义的迭代器，可用 `AntIterator` 对迭代器进行封装。`AnyIterator` 进行封装的做法是将迭代器包装到一个内部的对象中，而这个对象是引用类型。\t\n\n\n```\nvar i3 = AnyIterator(i1)\nvar i4 = i3\ni3.next() // 3\ni4.next() // 5\ni3.next() // 8\ni4.next() // 13\n```\n\n\n`i3` 和 `i4` 并不是相互独立的，`i3` 不再是一个结构体，将 `i3` 复值给 `i4` 时只是复值了引用，两个迭代器共享一份状态。\n\n## 无限序列\n\n序列和集合一个最重要的区别是序列可以是无限的，而集合不行。\n\n`FibsSequence` 就是一个无限序列，从上方的例子可以看出序列对 `next` 闭包的调用时延迟执行的，即序列的下一个值不会预先被计算，只在调用者需要的时候生成，否则定义完 `FibsSequence` 后程序会因为整数溢出而崩溃。\n\n## 不稳定序列\n\n序列和集合另一个重要的区别是序列并不保证可以被多次遍历，也就是说 `Sequence` 协议并不保证在迭代后元素是否销毁。\n\n```\nfor element in sequence {\n\t// do something\n}\nfor element in sequence {\n\t// 未定义行为\n}\n\n一个非集合的序列可能会在第二次 for-in 循环时产生随机的序列元素\n```\n\n\t\n## 栗子\n\n用枚举实现一个单向链表\n\n一个链表的节点只有两种可能，要么它是一个节点，要么代表链表的结尾，So 可以这样来定义链表：\n\n```\nenum List<Element> {\n    case end\n    indirect case node(Element, next: List<Element>)\n}\n```\n\n由于枚举是值类型，不能循环引用自身，故用 `indirect` 关键字来定义枚举成员告诉编译器将 `node` 当做引用，这样就可以循环引用自己了。尽管 `node` 会被当做引用，但这并不会改变枚举成员值类型的本质。\n\n为链表创建一个添加方法：\n\n```\nextension List {\n    func cons(_ x: Element) -> List {\n        return .node(x, next: self)\n    }\n}\n// 一个拥有三个元素的链表\nlet list = List.end.cons(1).cons(2).cons(3)\n\n```\n\n实现 `ExpressibleByArrayLiteral` 以便用数组字面量来初始化链表\n\n```\nextension List: ExpressibleByArrayLiteral {\n    init(arrayLiteral elements: Element...) {\n        self = elements.reversed().reduce(.end){result, element in\n            result.cons(element)\n        }\n    }\n}\n\nvar list2: List = [1, 2, 3] \n\n```\n\n链表其实也是一个栈，为链表实现 `push` 和 `pop` 方法：\n\n```\nextension List {\n    func push(_ x: Element) {\n        self.cons(x)\n    }\n    mutating func pop() -> Element? {\n        switch self {\n        case .end:\n            return nil\n        case let .node(x, next: trail):\n            self = trail\n            return x\n        }\n    }\n}\n\nvar list3: List = [1, 2, 3]\n\nlist3.pop() // 1\nlist3.pop() // 2\nlist3.pop() // 3\nlist3.pop() // nil\n\n```\n\n现在让 `List` 遵守 `Sequence` 协议就很简单了，我们只需要实现一个 `next` 方法即可同时遵守 `IteratorProtocol` 和 `Sequence` 协议\n\n```\nextension List: IteratorProtocol, Sequence {\n    mutating func next() -> Element? {\n        return pop()\n    }\n}\n```\n\n现在就可以在 `List` 上使用 `for-in` 了\n\n```\nvar list: List = [1, 2, 3, 4]\nfor element in list {\n    print(element)\n}\n// 1\n// 2\n// 3\n// 4\n```\n\n## Collection\n\n\n`Collection` 协议建立在 `Sequence` 的基础上。与序列不同 `Collection` 协议保证了集合类型的稳定性。遵守 `Collection` 协议的集合类型即指那些稳定的有限的序列，可以被多次遍历并保持一致。\n\n### 自定义集合类型\n\n下面以实现一个 FIFO 的队列为例，展示如何自定义集合类型。FIFO 队列我们可以用 `Array` 的 `push` 和 `remove(at: 0)` 来实现，但是因为数组中的元素是存储在一段连续的内存中，所以移除非尾部元素的时候其他元素都要移动去填补空白，这个操作的复杂度是 `O(n)`。So，下面我们实现一个更合理的队列类型。\n\n**第一步，定义一个协议来描述队列到底是什么**\n\n```\nprotocol Queue {\n    // 队列中元素类型\n    associatedtype Element\n    // 入队一个元素\n    mutating func enqueue(_ newElement: Element)\n    // 出队一个元素\n    mutating func dequeue()\n}\n```\n\n如上，`Queue` 协议只是定义了一个队列的基本属性，并没有定义这是一个先进先出队列，还是一个后进先出队列。\n\n**第二步，实现队列**\n\n```\nstruct FIFOQueue<Element>: Queue {\n    private var left: [Element] = []\n    private var right: [Element] = []\n    /// 将元素添加到队列末尾\n    /// - 复杂度： O(1)\n    mutating func enqueue(_ newElement: Element) {\n        right.append(newElement)\n    }\n    /// 从队列前端移除一个元素\n    /// - 复杂度：平摊O(1)\n    mutating func dequeue() ->Element? {\n        if left.isEmpty {\n            left = right.reversed()\n            right.removeAll()\n        }\n        return left.popLast()\n    }\n}\n```\n\n`dequeue` 方法中包含一个复杂度为 O(n) 的 `reversed` 操作，对于单个元素的操作来说可能耗时会长一些，但是对于非常多的 `push` 和 `pop` 操作来说，取出一个数的[平摊耗时](https://en.wikipedia.org/wiki/Amortized_analysis)是一个常数。\n\n**第三步，遵守 `Collection` 协议**\n\n目前 Swift 4.2 版本中 `Collection` 协议有7个属性，5个关联类型，11个实例方法，和两个下标方法。所幸其中大部分属性、方法都有默认的实现，要满足 `Collection` 协议，最少的情况下你只需满足以下条件：\n\n*  startIndex 和 endIndex 属性\n*  能够读取类型中元素的下标方法\n*  集合索引之间步进的 index(after:) 方法\n\n最后我们需要实现的方法和属性有：\n\n```\nprotocol Collection: Sequence {\n    /// 一个表示集合中位置的类型 \n    /// 不需要显示的申明，Swift 可以从属性和方法的定义中推断出来\n    associatedtype Index: Comparable\n    /// 一个非空集合中首个元素的位置\n    var startIndex: Index { get }\n    /// 集合中超过末位的位置---也就是比最后一个有效下标值大 1 的位置\n    var endIndex: Index { get }\n    /// 返回在给定索引之后的那个索引值\n    func index(after i: Index) -> Index\n    /// 访问特定位置的元素\n    subscript(position: Index) -> Element { get }\n}\n```\n\n让 `FIFOQueue` 遵守 `Collection` 协议\n\n\n```\nextension FIFOQueue: Collection {\n    public var startIndex: Int {\n        return 0\n    }\n    public var endIndex: Int {\n        return left.count + right.count\n    }\n    public func index(after i: Int) -> Int {\n        precondition(i < endIndex)\n        return i + 1\n    }\n    public subscript(position: Int) -> Element {\n        precondition((0..<endIndex).contains(position), \"下标越界\")\n        if position < left.endIndex {\n            return left[left.count - position - 1]\n        } else {\n            return right[position - left.count]\n        }\n    }\n}\n\n```\n\n\n**最后，遵守 `ExpressibleByArrayLiteral` 协议**\n\n\n自定义集合类型时，最好都实现一下 `ExpressibleByArrayLiteral` 协议，方便用数组字面量来创建类型。\n\n```\nextension FIFOQueue: ExpressibleByArrayLiteral {\n    public init(arrayLiteral elements: Element...) {\n        left = elements.reversed()\n        right = []\n    }\n}\n```\n\n\n简单的应用：\n\n\n\n```\nvar q: FIFOQueue = [1, 3, 5, 4, 6]\nq.dequeue() // 1\nq.enqueue(2) // left: [6, 4, 5, 3] right: [2]\nq.dequeue() // 3\nq.enqueue(9) // left: [6, 4, 5] right: [2, 9]\nlet sortedQ = q.sorted() // [2, 4, 5, 6, 9]\n```\n\n\n## 索引\n\n集合类型的 `index` 不一定都是整数类型，实现了 `Comparable` 协议的类型都可以作为集合类型 `index`。\n\n当集合发生改变时，索引可能会失效。有以下两种情况：\n\n* 索引本身仍是有效的，但是指向的是另外的元素。\n* 索引本身已失效，使用它访问集合会造成崩溃。\n\n```\nvar arr = [1, 2, 3, 4, 5]\nlet secondIndex = arr.index(after: arr.startIndex)\n\nvar val = arr[secondIndex] // 2\nvar lastVal = arr[lastIndex] // 5\n\narr.insert(9, at: 1)\nval = arr[secondIndex] // 9\n\nlet lastIndex = arr.index(before: arr.endIndex)\narr.removeLast()\nlastVal = arr[lastIndex] // 数组越界\n```\n\n\n## 切片\n\n所有集合类型都有切片操作的默认实现，且有一个接受 `Range<index>` 作为参数的下标方法。\n\n```\nvar arr = [1, 2, 3, 4, 5]\n// slice 的类型不是 Array<Int> 而是 ArraySlice<Int>\nvar slice = arr[1..<4] // [2, 3, 4]\n```\n\n标准库中实现了一些常用的快速获取切片的方法，如：`dropFirst()`、`dropLast()`、`suffix()`、`prefix()`等。\n\n```\nvar arr = [1, 2, 3, 4, 5]\nlet dropFirst = arr.dropFirst() // [2, 3, 4, 5]\nlet dropLast = arr.dropLast() // [1, 2, 3, 4]\nlet subffix2 = arr.suffix(2) // [4, 5]\nlet subffixFrom = arr.suffix(from: 1) // [2, 3, 4, 5]\nlet prefix = arr.prefix(3) // [1, 2, 3]\nlet prefixUpTo = arr.prefix(upTo: 3) // [1, 2, 3]\n```\n\n### 切片与原集合共享索引\n\n集合类型和它的切片拥有相同的索引。只要集合和它的切片在创建后没有改变，切片中某个索引位置上的元素，应当也存在于原集合中同样的索引位置上。这就引出一个问题，一个集合的索引不需要从0开始。\n\n```\nvar arr = [1, 2, 3, 4, 5]\nvar slice = arr.dropFirst()\nslice.startIndex // 1\n```\n\n这种情况下，访问 `slice[0]` 会崩溃，`slice` 的开始索引不再是0而是1。所以，不要假设集合类型的开始索引总是0，始终使用 `startIndex` 和 `endIndex` 访问集合的开始、结束索引。\n\n##### 不要长期存储切片实例\n\n切片会持有原集合整个存储的引用，而不仅仅是切片需要展示的内容，即使在原集合的生命周期结束后切片仍会持有原集合整个存储的引用。长期存储切片实例，切片的生命周期比原集合久，当原集合生命周期结束后会造成内存泄漏。\n\n\n## 特定的集合类型\n\n`Collection` 协议没有提供向后移动索引的方法，也没有提供像是插入、移除或者替换集合元素这样的方法。标准库中，有四个专门的集合类型协议来对 `Collection` 进行扩展。\n\n* BidirectionalCollection 一个即支持前向又支持后向遍历的集合\n* RandomAccessCollection 一个支持高效随机存取索引遍历的集合\n* MutableCollection 一个支持下标赋值的集合\n* RangeReplaceableCollection 一个支持将任意子范围的元素用别的集合中的元素记性替换的集合","tags":["Swift"]},{"title":"WKWebView Cookie 问题","url":"/2018/12/02/WKWebView-cookie-问题/","content":"\n每个 WKWebView 都有一个私有的 Cookie 存储，不会与标准的 Cookie 容器 `NSHTTPCookieStorage` 共享。WKWebView cookie 问题就在于 WKWebView 发起请求不会自动带上存储于 `NSHTTPCookieStorage` 容器中的 Cookie。\n\n而 UIWebView 则没有这个问题，UIWebView 发起请求会自动带上 `NSHTTPCookieStorage` 中的 Cookie。 UIWebView 没有私有的 Cookie 存储，APP 中所有的 UIWebView 共享同一个`NSHTTPCookieStorage` 容器中的 Cookie 信息。\n\n## 解决方案\n\n### iOS 11 之前的系统\n\n1. WKWebView loadRequest 前，在 request header 中设置 Cookie，解决首个请求 Cookie 带不上的问题\n\n\t```\n\tNSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://test.com/\"]];\n\tNSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];\n    NSArray *cookies = cookieStorage.cookies;\n    NSMutableString *cookieString = [[NSMutableString alloc] init];\n    for (NSHTTPCookie *cookie in cookies) {\n        [cookieString appendFormat:@\"document.cookie = '%@=%@;path=/';\",cookie.name,cookie.value];\n    }\n    [request setValue:cookieString forHTTPHeaderField:@\"Cookie\"];\n    [webView loadRequest:request];\n\t```\n2. 通过 document.cookie 设置 Cookie，解决后续请求 Cookie 问题\n\n\t```\n\tNSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];\n    NSArray *cookies = cookieStorage.cookies;\n    NSMutableString *cookieString = [[NSMutableString alloc] init];\n    for (NSHTTPCookie *cookie in cookies) {\n        [cookieString appendFormat:@\"document.cookie = '%@=%@;path=/';\",cookie.name,cookie.value];\n    }\n    WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource: cookieString injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];\n    WKUserContentController *userContentController = [WKUserContentController new];\n    [userContentController addUserScript:cookieScript];\n\t```\n\n> 注：document.cookie() 无法跨域设置 cookie\n\t\n### iOS 11 及之后的系统\n\niOS 11 及之后的系统可通过 `WKHTTPCookieStore` 来管理 HTTP Cookie 信息\n\n```\nif (@available(iOS 11.0, *)) {\n    WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];\n    NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];\n    NSArray *cookies = cookieStorage.cookies;\n    WKWebsiteDataStore *dataStore = [WKWebsiteDataStore nonPersistentDataStore];\n    NSInteger count = cookies.count;\n    for (NSInteger i = 0; i < count; i++) {\n        NSHTTPCookie *cookie = cookies[i];\n        [dataStore.httpCookieStore setCookie:cookie completionHandler:nil];\n    }\n    config.websiteDataStore = dataStore;\n    WKWebView *webView = [[WKWebView alloc] initWithFrame:frame\n                                            configuration:config];\n}\n```\n\n> 注：\n> \n> WKWebsiteDataStore 要用 nonPersistentDataStore 新建一个，使用 defaultDataStore 创建设置的 Cookie 信息不会生效。\n> \n> WKWebViewConfiguration 要在 WKWebView 创建的时候创建，WKWebView 创建后再更改 WKWebViewConfiguration 配置信息不会生效。\n\n\n## WKProcessPool\n\n> A WKProcessPool object represents a pool of Web Content processes.\n\n苹果开发者文档对 WKProcessPool 的定义如上，WKProcessPool 代表 web 内容的进程池。WKWebView 初始化时会从 WKWebViewConfiguration 中指定的 WKProcessPool 进程池中创建一个新的 web 内容进程，或者使用该进程池中一个已存在的进程。\n\n多个 WKWebView 之间不会共享 Cookie 信息，如上所述，可通过让多个 WKWebView 共享同一个 WKProcessPool 实例，来实现多个 WKWebView 之间共享 Cookie 信息。\n\n示例：\n\n```\n// WKProcessPool+Shared.h\n\n#import <WebKit/WebKit.h>\n\n@interface WKProcessPool (Shared)\n\n+ (WKProcessPool *)sharedWKProcessPool;\n\n@end\n\n// WKProcessPool+Shared.m\n\n#import \"WKProcessPool+Shared.h\"\n\n@implementation WKProcessPool (Shared)\n\n+ (WKProcessPool *)sharedWKProcessPool {\n    static WKProcessPool *pool;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        pool = [[WKProcessPool alloc] init];\n    });\n    return pool;\n}\n\n@end\n\n// 配置 WKWebView\n\nWKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];\nconfig.processPool = [WKProcessPool sharedWKProcessPool];\nWKWebView *webView = [[WKWebView alloc] initWithFrame:frame\n                                            configuration:config];\n```\n\t\n\t\n\t\n## WKWebView 白屏问题\n\nUIWebView 当内容占用太大的时候，App 会 crash。而在 WKWebView 上当内容占用太大的时候，App 不会 crash，WebContent process 会 crash，从而出现白屏的现象，这个时候 webView.URL 会变为 nil。\n\niOS 9以后 WKNavigationDelegate 中新增了一个方法：\n\n```\n- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0));\n```\n\nWKWebView 页面即将白屏的时候，系统会调用上面的方法，此时 webView.URL 还有值不是 nil，所以可以通过简单的 [webView reload] 来解决白屏问题。\n\t","tags":["iOS, WKWebView"]},{"title":"JavaScript 风格指南","url":"/2018/12/02/JavaScript风格指南/","content":"\n## 编码规范\n\n### 判空\n\n* object -> true \n* Undefined -> false\n* Null -> false\n* Booleans -> \n* Number -> +0,-0,NaN：false， 其他值：true\n* String -> 空字符串'' : flase，其他值：true\n\n简化判空操作\n\n```\n// bad\nlet a\nif(a != null && typeof(a) != undefined && a != ''){\n    // a有内容时做一些处理  \n}\n\n// good\nif (!!a) {\n\t// a有内容时做一些处理  \n}\n\nor \n\nif (a) {\n\t// a有内容时做一些处理 \n}\n```\n> 注意：空对象 `{}`、空数组 `[]` 均会返回 `true`\n\n### let、var、const\n\n* 变量用`let`声明，常量用`const`声明，避免使用`var`\n* `let`、`const`都是块级作用域\n\n### 避免不必要的三元表达式\n\n```\n// bad\nconst foo = a ? a : b\nconst bar = c ? true : false\nconst baz = c ? false : true\n\n// good\nconst foo = a || b\nconst bar = !!c\nconst baz = !c\n```\n\n### 不要直接调用`Object.prototype`上的方法，比如，`hasOwnProperty`，`propertyIsEnumerable`和`isPrototypeOf`\n\n> `Object.prototype` 上的方法可能会被错误的覆盖\n\n```\n// bad \nconsole.log(object.hasOwnProperty(key))\n\n// good\nconsole.log(Object.prototype.hasOwnProperty.call(object, key))\n\nlet a = {\n\tkey: 1,\n\thasOwnProperty () {\n\t\treturn false\n\t}\n}\n\nconsole.log(a.hasOwnProperty('key')) // false\nconsole.log(Object.prototype.hasOwnProperty.call(a, 'key')) // true\n```\n\n### `call`、`apply`、`bind`\n\n每个函数都包含两个非继承而来的方法：`call()`和`apply()`。这两个函数的用途都是在特定的作用域中调用函数，等同于设置函数体内`this`对象的值。\n\n* `apply()`方法接收两个参数，一个是函数运行的作用域，另一个是参数数组。第二个参数可以是`Array`类型，也可以是`arguments`对象。\n\n```\nfunction sum (a, b) {\n\treturn a + b\n}\n\nfunction callSum (a, b) {\n\treturn sum.apply(this, arguments)\n}\n\nfunction callSum2 (a, b) {\n\treturn sum.apply(this, [a, b])\n}\n\nconsole.log(callSum(1,2)) // 3\nconsole.log(callSum2(1,2)) // 3\n```\n\n* `call()`方法与`apply()`的作用相同，区别在于传递给函数的参数必须逐个列举出来\n\n```\nfunction callSum (a, b) {\n\treturn sum.call(this, a, b)\n}\n\nconsole.log(callSum(1,2)) // 3\n```\n\n应用：\n\n```\nwindow.color = 'red'\nconst obj = {\n\tcolor: 'orange'\n}\n\nfunction sayColor () {\n\tconsole.log(this.color)\n}\n\nsayColor() // red\nsayColor.call(this) // red\nsayColor.call(window) // red\nsayColor.call(obj) // orange\n```\n\n* `bind()`函数在 ES5 中定义的，这个方法会创建一个函数的实例，其`this`值会被绑定到传给`bind()`函数的值。\n\n```\nwindow.color = 'red'\nconst obj = {\n\tcolor: 'orange'\n}\n\nfunction sayColor () {\n\tconsole.log(this.color)\n}\n\nconst objSayColor = sayColor.bind(obj)\n\nsayColor() // red\nobjSayColor() // orange\n```\n\n### 表达式解构\n\n> 本质上，这种写法是一种\"模式匹配\"，只要等号两边的模式相同，左边的变量就会被赋予对应的值，解构不成功变量的值等于 undefined。\n\n* 数组解构赋值\n\n```\n\t// 基本用法\n\tlet [a, b] = [1, 2, 3]\n\tconsole.log(a, b) // 1 2\n\t\n\t// 多维数组\n\tlet [c, [d]] = [1, [4, 5]]\n\tconsole.log(c, d) // 1, 4\n```\n指定默认值\n\t\n```\n\tlet [a, b] = [1]\n\tconsole.log(a, b) // 1, undefined\n\t\n\tlet [a, b = 2] = [1]\n\tconsole.log(a, b) // 1, 2\n\t\n\tlet [a, b = 2] = [1, undefined]\n\tconsole.log(a, b) // 1, 2\n\t\n\tlet [a, b = 2] = [1, null]\n\tconsole.log(a, b) // 1, null\n```\n> 注意：ES6 中使用严格相等运算符`===`判断是否相等，所以只有当一个数组成员严格等于 undefined 时默认值才会生效。例如，有一个数组成员为 null 则默认值会生效，匹配后的值为 null。\n\t\n* 对象解构赋值\n\t\n\t对象解构与数组解构一个重要的不同在于，数组元素按顺序排列，变量的取值由位置决定，而对象的属性没有顺序，变量名必须与属性名相同，才能取到值。\n\t\n```\n\tlet {key1, key2} = {key1: 'first key', key2: 'second key'}\n\tconsole.log(key1, key2) // first key second key\n```\n嵌套对象解构\n\t\n```\n\tlet {a, b: {c}} = {a: 1, b: {c: 3}}\n\tconsole.log(a, c) // 1 3\n```\n\n* 函数参数解构赋值\n\n```\n\t// bad\n\tfunction getFullName(user) {\n\t  const firstName = user.firstName;\n\t  const lastName = user.lastName;\n\t\n\t  return `${firstName} ${lastName}`;\n\t}\n\t// good\n\tfunction getFullName({ firstName, lastName }) {\n\t  return `${firstName} ${lastName}`;\n\t}\n```\n\n* 函数需返回多个值且不在关心顺序时，使用对象解构返回，而不是数组。\n\n```\n\t// bad\n\tfunction processInput(input) {\n\t  return [left, right, top, bottom];\n\t}\n\t// 需要考虑返回值的顺序\n\tconst [left, __, top] = processInput(input);\n\t\n\t// good\n\tfunction processInput(input) {\n\t  return { left, right, top, bottom };\n\t}\n\t// 不需要考虑顺序，需要哪个值取哪个\n\tconst { left, top } = processInput(input);\n```\n\n### 箭头函数\n\n* 几种常见写法\n\n```\n\t// 只有一个参数可省略括号\n\t// 函数体值一行代码可省略大括号和return\n\t1.x => x + 'world'\n\t2.(x, y) => x + y\n\t3.x => {\n\t\treturn x + 'world'\n\t}\n\t4.(x, y) => {\n\t\treutrn x + y\n\t}\n```\n\n* 箭头函数的上下文（`this`）会绑定为定义函数所在作用域的上下文\n\n```\n\tlet obj = {\n\t\thello: 'object hello',\n\t\tsayHello () {\n\t\tconst temp = () => {\n\t\t\t\treturn this.hello\n\t\t\t}\n\t\t\treturn temp\n\t\t}\n\t}\n\t\n\twindow.hello = 'window hello'\n\twindow.sayHello = obj.sayHello()\n\twindow.sayHello() // object hello\n```\n上面的代码等价于：\n\n```\n\tlet obj = {\n\t\thello: 'object hello',\n\t\tsayHello () {\n\t\tconst temp = (function () {\n\t\t\t\treturn this.hello\n\t\t\t}).bind(this)\n\t\t\n\t\t\treturn temp\n\t\t}\n\t}\n\n```\n> 注意：箭头函数对上下文的绑定是强制性的，无法通过`apply`和`call`改变其上下文。\n\t\n* 使用匿名函数时，使用箭头函数定义。\n\n> 箭头函数的上下文绑定特性，绑定的`this`通常都是我们希望的。\n\n```\n\t// bad\n\t[1, 2, 3].map(function (x) {\n\t\treturn x * x\n\t})\n\t\n\t// good\n\t[1, 2, 3,].map((x) => {\n\t\treturn x * x\n\t})\n\t\n```\n\t\n### 尽量使用高阶函数代替 `for-in` 和 `for-of`\n\n> 高阶函数相比 `for-in` 和 `for-of` 具有更高的可读性，且减少了一些边界条件的考虑。\n\n```\nconst numbers = [1, 2, 3, 4, 5]\n\n// bad\nlet sum = 0\nfor (let num of numbers) {\n  sum += num\n}\nsum === 15\n\n// good\nlet sum = 0\nnumbers.forEach((num) => {\n  sum += num\n});\nsum === 15\n\n// best\nconst sum = numbers.reduce((total, num) => total + num, 0)\nsum === 15\n\n// bad\nconst increasedByOne = []\nfor (let i = 0; i < numbers.length; i++) {\n  increasedByOne.push(numbers[i] + 1)\n}\n\n// good\nconst increasedByOne = []\nnumbers.forEach((num) => {\n  increasedByOne.push(num + 1)\n})\n\n// best\nconst increasedByOne = numbers.map(num => num + 1)\n```\n\n## 模块化编程\n\n在 ES6 之前，javaScript 一直没有模块体系，无法将一个大程序拆分成互相依赖的小文件，因此javaScript 社区制定了一些模块化加载方案，最主要的就是 `CommonJS` 和 `AMD` 前者用于服务器，后者用于浏览器。ES6 在语言层面上实现了模块功能，而且相当简单完全可以取代 `CommonJS` 和 `AMD` 规范。\n\n### ES6 模块\n\nES6 模块自动采用严格模式，不管是否在模块头部加上 `\"use strict\"`\n\n#### export 命令\n\n模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n\n一个模块就是一个单独的文件，文件内定义的所有变量都是私有的，外部无法获取。如果希望外部读取模块的某个变量，只能通过 `export` 导出改变量。\n\n例：\n\n```\n// moduleA.js\nexport let name = 'first name'\nexport let age = 18\n```\n\n除了上述写法一个一个导出变量，还有另外一种写法：\n\n```\nlet name = 'first name'\nlet age = 19\n\nexport { name, age }\n```\n\n`export` 命令除了导出变量，还可以导出函数或类\n\n```\nexport function sayHello () {\n\tconsole.log('hello')\n}\n```\n\n一般情况导出的变量就是本来定义的名字，如果希望重命名可以通过 `as` 关键字实现\n\n```\nlet name = 'first name'\n\nexport { name as firstName }\n```\n\n#### import 命令\n\n使用 `export` 定义了模块的接口后，其他 JS 文件可通过 `import` 命令引入这个模块\n\n```\n// main.js\n\nimport {name, age} from './moduleA.js'\n```\n\n`import` 命令接受一对大括号，在括号里指定要从其他模块导入的变量名，必须与模块中导出的名称相同。\n\n如果想对 `import` 的变量重新命名，可通过 `as` 关键字实现：\n\n```\nimport { name as firstName } from './moduleA.js'\n```\n\n`import` 命名是在编译阶段执行的，所以不能使用表达式和变量，这种在运行时才能得到结果的语法结构。\n\n```\n// 错误\nimport {'n' + 'ame'} from './moduleA.js'\n\n// 错误\nif (condition === 1) {\n\timport {name} from './moduleA.js'\n} else {\n\timport {name} from './moduleB.js'\n}\n```\n\n除了加载某个指定的输出值，还可通过 `*` 将模块的所有输出导出到一个对象上\n\n```\nimport * as obj from './moduleA.js'\n\nconsole.log(obj.name) // first name\nconsole.log(obj.age)  // 18\n```\n\n#### export default 命令\n\n`export default` 为模块指定默认输出，一个文件或模块中只能有一个 `export default`\n\n```\n// export-default.js\n\nexport default function () {\n\tconsole.log('hello')\n}\n\n// or\n\nconst sayHello = function () {\n\tconsole.log('hello')\n}\n\nexport default sayHello\n\n```\n\n`import` 引入模块默认输出是不需要大括号，且可以任意指定模块默认输出的名称，不需要知道原模块中输出的名称\n\n```\nimport say from './export-default.js'\n\nsay() // hello\n```\n\n本质上 `export default` 就是输出一个叫做 `default` 的变量或者方法，所以`export default` 后面不能跟变量申明语句，直接导出变量表达式。\n\n```\n// 正确\nexport let a = 4\n// 错误\nexport default let a = 4\n// 正确\nlet a = 4\nexport default a\n```\n\n#### export 和 export default 区别\n\n* export与export default均可用于导出常量、函数、文件、模块等\n* 在一个文件或模块中，export、import可以有多个，export default仅有一个\n* 通过export方式导出，在导入时要加{ }，export default则不需要\n* export能直接导出变量表达式，export default不行\n\n\n### CommonJS\n\nCommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如服务器和桌面应用。\n\nCommonJS 是一种规范，为了解决 JavaScript 作用域问题而定义的模块形式。可以时每个模块在自身的命名空间中执行。模块必须通过`module.exports`到处对外的变量或接口，荣拓`require()`来导入模块。node.js 模块系统即参照 CommonJS 规范实现的。\n\n浏览器不兼容 CommonJS 的根本原因是缺少四个 Node.js 的环境变量：\n\n* module\n* exports\n* require\n* global\n\n要在浏览器环境兼容 CommonJS 可以使用一些转换工作，如 `Browserify`, `Browserify`是最常用的 CommonJS 格式转换工具。\n\n例：\n\n```\n// moduleA.js\nmodule.exports = {\n\ta: 'a',\n\tb: 'b'\n}\n```\n\n```\n// moduleB.js\nconst mod = require('./moduleA.js')\nconst aFromModuleA = mod.a\n```\n\n> CommonJS 是同步加载模块\n\n### AMD\n\nAMD 是为浏览器环境设计的，定义了一套 JavaScript 模块依赖异步加载标准，来解决同步加载的问题。\n\n模块通过 `define` 函数定义在闭包中，格式如下：\n\n```\ndefine(id?: String, dependencies?: String[], factory: Function|Object)\n```\n\n`id` 是模块的名字，可选参数。`dependencies` 指定了所需要依赖的模块列表，是一个数组，也是可选参数。每个模块的输出将作为参数一次传入 `factory`。如果没有指定 `dependencies` 它的默认值是 `[\"require\", \"exports\", \"module\"]`\n\n`factory` 是模块的具体实现，可以是一个函数或一个对象。如果是函数，那么函数的返回值就是模块的输出接口或值。\n\n定义一个模块，依赖`jQuery`，如下：\n\n```\ndefine('myModule', [\"jQuery\"], function ($) {\n\t$('body').text('hello world!')\n})\n```\n\n在模块内部引用依赖\n\n```\ndefine('myModule', function (require) {\n\tconst $ = require('jQuery')\n\t$('body').text('hello world')\n})\n```\n\n具体应用可看 `RequireJS`\n\n### 模块化编码建议\n\n* 总是使用`import/export`，不再使用 `CommonJS`、`AMD`等模块化方案。\n* 不用通配符`import`\n\n\t```\n\t// bad\n\timport * as Module from './moduleA'\n\t\n\t// good\n\timport Module from './moduleA'\n\t```\n* 从同一个 module `import` 多个值写在一行\n\n\t```\n\t// bad\n\timport foo from 'foo'\n\timport { named1, named2 } from 'foo'\n\t\n\t// good\n\timport foo, { named1, named2 } from 'foo'\n\t\n\t// good\n\timport foo, {\n\t  named1,\n\t  named2,\n\t} from 'foo'\n\t```\n\t\n* 只导出常量，不要导出可变绑定。\n\n\t```\n\t// bad\n\tlet foo = 3;\n\texport { foo }\n\t\n\t// good\n\tconst foo = 3;\n\texport { foo }\n\t```\n\t\n## Promise\n\n`Promise` 是 `JavaScript` 异步编程的一种解决方案，ES6 将其写入了语言标准，提供了原生的`Promise`对象。\n\n`Promise` 设计上具有原子性，即只有两种状态，未开始和结束（成功和失败均是结束），也就是说 `Promise` 一但开始便不能中途取消，会得到一个结束状态成功或失败。未开始、成功、失败这三个状态分别用 `pending`、`fulfilled`和`rejected`表示。\n\n### 基本用法\n\n`Promise` 构造函数接收一个函数参数，函数有两个参数`resolve`和`reject`，`resolve` 用于将`Promise`对象的状态从*未开始* 变为 *成功*，`reject` 用于将`Promise`对象的状态从 *未开始* 变为 *失败*。要创建一个异步函数只需返回一个`Promise`对象即可。\n\n如下，创建一个异步函数：\n\n```\nfunction fetchData() {\n\treturn new Promise((resolve, reject) => {\n\t\tif (/*异步操作成功*/) {\n\t\t\tresolve(value)\n\t\t} else {\n\t\t\treject(error)\n\t\t}\n\t})\n}\n```\n\n> `Promise` 的参数建议用箭头函数来定义，利用箭头函数的上下文绑定将`this`绑定为函数所在的作用域，这通常是我们所期望的。\n\n创建异步函数后，调用时可用`.then()`来添加`resolve`时的回调函数，`.catch`添加`reject`时的回调函数。`resolve` 中的参数会传递给`.then()`添加的回调函数，同理`reject`的参数亦会传递给`.catch()`添加的回调函数。\n\n```\nfunction fetchData() {\n\treturn new Promise((resolve, reject) => {\n\t\tif (/*异步操作成功*/) {\n\t\t\tresolve(1)\n\t\t} else {\n\t\t\treject('error message')\n\t\t}\n\t})\n}\n\nfetchData().then((response) => {\n\t// success\n\tconsole.log(response) \n}).catch((error) => {\n\t// fail\n\tconsole.log(error) \n})\n// 1\n// error message\n```\n\n> 注：`resolve`和`reject` 并不会终止`Promise`的函数的执行。\n\n```\nnew Promise((resolve, reject) => {\n  resolve(1);\n  console.log(2);\n}).then(r => {\n  console.log(r);\n});\n// 2\n// 1\n```\n\n### 链式调用\n\n`.then()` 方法返回的是一个**新的**`Promise`对象（注意不是原来的那个），因此我们可以用链式写法添加多个`.then()`处理函数，多个`.then()`会添加顺序依次调用。`.then()`中传递参数给下一个`.then()`只需 `return` 对应的值即可。\n\n```\nfunction fetchData() {\n\treturn new Promise((resolve, reject) => {\n\t\tif (true) {\n\t\t\tresolve(1)\n\t\t} else {\n\t\t\treject('error message')\n\t\t}\n\t})\n}\n\nfetchData().then((response) => {\n\t// success\n\tconsole.log(response) \n\treturn 2\n}).then((res) => {\n\tconsole.log(res) \n}).catch((error) => {\n\t// fail\n\tconsole.log(error)\n})\n// 1\n// 2\n```\n\n同理，可以链式添加多个`.catch()`，`.catch()` 中可以抛出错误被后续的`.catch()` 捕获。\n\n```\nfunction fetchData() {\n\treturn new Promise((resolve, reject) => {\n\t\tif (false) {\n\t\t\tresolve(1)\n\t\t} else {\n\t\t\treject('error message')\n\t\t}\n\t})\n}\n\nfetchData().then((response) => {\n\t// success\n\tconsole.log(response)\n}).catch((error) => {\n\t// fail\n\tconsole.log(error)\n\ty + 1\n}).catch((error) => {\n\tconsole.log(error)\n})\n// error message\n// ReferenceError: y is not defined\n```\n\n> 注：`.catch()`不仅会捕获`reject`的错误信息，`.then()`中出现错误一会被`.catch()`捕获。\n\n### `Promise.prototype.finally()`\n\n`.finally()`方法用于添加不管`Promise`状态如何都会执行的操作。`.finally()`回调函数不接受任何参数，即无法知道`Promise`的状态是`fulfilled`还是`rejected`，故`.finally()`中的操作不应该包含于状态有关的逻辑。\n\n```\nfunction fetchData() {\n\treturn new Promise((resolve, reject) => {\n\t\tif (true) {\n\t\t\tresolve(1)\n\t\t} else {\n\t\t\treject('error message')\n\t\t}\n\t})\n}\n\nfetchData().then((response) => {\n\t// success\n\tconsole.log(response)\n}).catch((error) => {\n\t// fail\n\tconsole.log(error)\n}).finally(() => {\n\tconsole.log('finally.........')\n})\n// 1\n// finally.........\n```\n\n### `Promise.all()`\n\n`Promise.all()`方法用于将多个 `Promise` 实例包装成一个`Promise`实例。`Promise.all()`接收一个数组作为参数，数组中的元素必须是`Promise`实例，如果不是会调用`Promise.resolve`方法将参数转换为`Promise`实例，再做进一步的处理。\n\n```\nconst p = Promise.all([p1, p2, p3])\n```\n\n一个简单的例子如上，p1、p2、p3均为`Promise`实例，p的状态有以下两种情况：\n\n* p1、p2、p3 的状态均为`fulfilled`时，p 的状态才会变成`fulfilled`，此时p1、p2、p3的返回值组成一个数组传给 p 的`.then()`回调函数。\n\n\t```\n\tconst p1 = new Promise((resolve, reject) => {\n\t\tresolve(1)\n\t}).then((res) => {\n\t\treturn `message from p1 ${res}`\n\t})\n\t\n\tconst p2 = new Promise((resolve, reject) => {\n\t\tresolve(2)\n\t}).then((res) => {\n\t\treturn `message from p2 ${res}`\n\t})\n\t\n\tconst p3 = new Promise((resolve, reject) => {\n\t\tresolve(3)\n\t}).then((res) => {\n\t\treturn `message from p1 ${res}`\n\t})\n\t\n\tPromise.all([p1, p2, p3]).then((res) => {\n\t\tconsole.log(res)\n\t})\n\t// [ 1, 2, 3]\n\n\t```\n* p1、p2、p3 中只要有一个状态为`rejected`，p 的状态就会变成 `rejected`，此时第一个`reject`的实例的返回值会传递给 p 的回调函数。\n\n\t```\n\tconst p1 = new Promise((resolve, reject) => {\n\t\tresolve(1)\n\t}).then((res) => {\n\t\treturn res\n\t})\n\t\n\tconst p2 = new Promise((resolve, reject) => {\n\t\treject(2)\n\t}).then((res) => {\n\t\treturn res\n\t})\n\t\n\tconst p3 = new Promise((resolve, reject) => {\n\t\treject(3)\n\t}).then((res) => {\n\t\treturn res\n\t})\n\t\n\tPromise.all([p1, p2, p3]).then((res) => {\n\t\tconsole.log(res)\n\t}).catch((error) => {\n\t\tconsole.log(error)\n\t})\n\t// 2\n\t```\n\t\n> 注：只有p1、p2、p3中`reject`的按个实例没有`.catch()`方法时才会调用`Promise.all()`的`catch`方法。\n\t\n```\n\tconst p1 = new Promise((resolve, reject) => {\n\t\tresolve(1)\n\t}).then((res) => {\n\t\treturn res\n\t})\n\t\n\tconst p2 = new Promise((resolve, reject) => {\n\t\treject(2)\n\t}).then((res) => {\n\t\treturn res\n\t}).catch((error) => {\n\t\tconsole.log(`error occure in p2 ${error}`)\n\t})\n\t\n\tconst p3 = new Promise((resolve, reject) => {\n\t\treject(3)\n\t}).then((res) => {\n\t\treturn res\n\t})\n\t\n\tPromise.all([p1, p2, p3]).then((res) => {\n\t\tconsole.log(res)\n\t}).catch((error) => {\n\t\tconsole.log(error)\n\t})\n\t// error occure in p2 2\n\t// 3\n\n```\n\t\n### `Promise.race()`\n\n`Promise.race()` 与 `Promise.all()`类似，将多个 Promise 实例，包装成一个新的 `Promise` 实例。\n\n不同之处在于，只要参数中有一个实例的状态改变了，`Promise.race()`的状态就会耕者改变，率先改变的 `Promise` 实例返回值传递给`Promise.race()`的回调函数。\n\n```\nconst p1 = new Promise((resolve, reject) => {\n\tsetTimeout(() => resolve(1), 2000)\n}).then((res) => {\n\tconsole.log('p1 resolved')\n\treturn res\n})\n\nconst p2 = new Promise((resolve, reject) => {\n\tsetTimeout(() => resolve(2), 1000)\n}).then((res) => {\n\tconsole.log('p2 resolved')\n\treturn res\n})\n\nconst p3 = new Promise((resolve, reject) => {\n\tresolve(3)\n}).then((res) => {\n\tconsole.log('p3 resolved')\n\treturn res\n})\n\nPromise.all([p1, p2, p3]).then((res) => {\n\tconsole.log(res)\n}).catch((error) => {\n\tconsole.log(error)\n})\n// p3 resolved\n// 3\n// p2 resolved\n// p1 resolved\n```","tags":["JavaScript"]},{"title":"Vue 首屏加载优化","url":"/2018/12/01/Vue-首屏加载优化/","content":"\n优化方向：\n\n* 路由懒加载\n* CDN 优化\n* Gzip 优化\n\n>Vue CLI 2 和 Vue CLI 3 构建的项目均适用以下优化方案，本文主要基于 Vue CLI 2 进行讲解。\n\n## 准备工作\n\n通过 Vue CLI 2 和 webpack 模板构建一个基础的项目，在 vue、vuex、vue-router 的基础上添加 mint-ui 和 axios 两个常用的库。创建两个路由 Home 和 About。创建完成后 build 一次，用作后续优化的参照。如下图：\n\n![original](/img/p1-1.png)\n\n将项目部署在本地 Apache 服务器，禁用浏览器缓存，网速限定为 Slow 3G 首页加载情况如下图：\n\n![](/img/p1-0.jpg)\n\n如上图，未优化的情况需要12s左右才能加载完成。\n\n## 路由懒加载\n\n构建应用过程中生成的 app.js 主要包含项目中的业务代码，随着项目越来越复杂 app.js 文件会变得非常大，严重影响首屏加载速度，显然在首屏加载的时候就把所有的 JavaScript 加载进来也是不合理的。\n\n我们可以结合 Vue 的异步组件和 Webpack 的代码分割功能，实现路由懒加载功能。把不同路由对应的组件分割成不同的代码块，只有当路由被访问的时候才加载对应的组件，有效减少首屏加载时加载的文件大小。\n\n我们可以通过如下格式定义能够被 Webpack 自动进行代码分割的异步组件：\n\n```\nconst Foo = () => import(/* webpackChunkName: \"group-foo\" */ './Foo.vue')\n```\n\n`webpackChunkName` 是一个特殊的注释语法(需要 Webpack > 2.4)，为分割后的代码块提供了一个 chunk name，构建应用后 Foo.vue 组件对应的代码块为 group-foo.js。\n\n\n为项目添加路由懒加载功能，如下图：\n\n![](/img/p1-3.jpg)\n\n`webpackPrefetch` 和 `webpackPreload` 同`webpackChunkName` 是一个特殊的注释语法，prefetch 代表资源在将来的导航中会被使用，preload 代表资源要在当前导航中使用，主要区别如下：\n\n* preload chunk 与父 chunk 并行加载，prefetch chunk 在父 chunk 加载完成后加载。\n* preload chunk 具有 medium 优先级可立即下载，prefetch chunk 在浏览器空闲时才下载。\n* preload chunk 应被父 chunk 立即请求，prefetch chunk 可以在将来任何时候使用。\n\n想了解更多更详细的 Vue 异步组件和 Webpack 代码分割功能可参考官方文档 [Vue 异步组件](https://router.vuejs.org/zh/guide/advanced/lazy-loading.html) 和 [Webpcak Code Spliting](https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules)。\n\n重新 build 一次，如下图：\n\n![](/img/p1-4.jpg)\n\n可以看到 app.js 从12.2KB 变成了 10.3KB，同时多了两个 js 文件 hello-world.js 和 about.js。重新部署一遍，首屏加载情况如下图：\n\n![](/img/p1-5.jpg)\n\n从上图可以看到，首屏加载的时候并没有加载 About.vue 组件对应的 1.js 文件，只有在我们访问 `/about` 路由的时候才会加载。\n\n由于这个演示项目只是一个空项目 About.vue 只有 450bytes 大小，所以对于首屏加载的速度并没有什么影响，但是在具体的项目中，首页加载时对一些不必要的东西延迟加载，对于首页加载速度来说是很有帮助的。\n\n## CDN 优化\n\n将项目中依赖的第三方库使用 CDN 链接引入，不仅是首屏加载速度上会有较大的提升，且在高并发时大部分的静态资源都请求的第三方的 CDN 资源可以有效减少我们自己服务器的带宽压力。\n\n以本文的演示项目为例优化步骤如下：\n\n1. 将 vue、vuex、vue-router、mint-ui 和 axios 这五个库全部改为用 CDN 导入。在 HtmlWebpackPlugin 中配置 CDN 链接，然后在 index.html 中用循环语法插入 js 和 css 的 CDN 链接。\n\n\tHtmlWebpackPlugin 配置\n\n\t![](/img/p1-6.jpg)\n\n\tindex.html\n\n\t![](/img/p1-7.jpg)\n\n\t> html 中使用 EJS 语法循环插入 CDN 链接，EJS 一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。更多信息可查看[官方文档](https://ejs.bootcss.com)。\n\n\n2. 在 build/webpack.base.conf.js 中添加 `externals ` 不把从 CDN 导入的库打包到 bundle 中，如下：\n\n\t```\n\texternals: {\n    \t'vue': 'Vue',\n    \t'vue-router': 'VueRouter',\n    \t'vuex': 'Vuex',\n    \t'axios':'axios',\n    \t'mint-ui': 'MINT',\n  \t}\n\t```\n\t键名是 import 的 npm 包名，键值是该库暴露的全局变量。\n\t> `externals` 详细信息可查看官方文档 [Externals](https://webpack.js.org/configuration/externals/)。\n\n3. 卸载依赖的 npm 包，`npm uninstall axios mint-ui vue vue-router vuex`\n\n4. 删除 main.js 中 mint-ui 相关的代码\n\n重新构建一次，优化前后文件对比如下：\n\n优化后：\n\n![](/img/p1-9.jpg)\n\n优化前：\n\n![](/img/p1-4.jpg)\n\n从以上对比我们可以看到以下两点：\n\n1. app.css 从 33.5KB 降到了只有 432bytes，app.css 包含的是压缩后的样式文件，由于我们把 mint-ui 的样式直接通过 CDN 链接引入，所以现在 app.css 中只包含少量的项目中的 css。\n2. vendor.js 从 244KB 降到了只有 828bytes，体积大幅度减少。vendor.js 主要包含的是项目中依赖的第三方库源码，所以在把 5 个依赖库全部转为 CDN 链接后，体积得到了大幅度的减少，里面已经没有了第三方库了。\n\n禁用浏览器缓存，网速限制为 Slow 3G，优化后的首页加载情况如下图：\n\n![](/img/p1-11.jpg)\n\n与优化之前对比，加载时间从12秒左右减少到了9秒左右，快了25%左右。\n\n## Gzip 优化\n\n> 开启 Gzip 的方式主要是通过修改服务器配置，本文只讨论 Gzip 前端能做的事情。\n\n使用 Gzip 两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。服务器在返回 js 文件的时候，会先判断是否有 .gz 后缀的文件，如果有就直接返回，否则在压缩后返给浏览器，所以我们在 build 的时候做好压缩也就不用占用服务器的 CPU 资源去压缩。\n\n首先，安装 `compression-webpack-plugin`\n\n```\nnpm install --save-dev compression-webpack-plugin\n```\n\n然后，把 config/index.js 中 productionGzip 设置为 true\n\n```\nproductionGzip: true,\nproductionGzipExtensions: ['js', 'css']\n```\n\n重新 build，可以发现多了一些 .gz 的文件\n\n![](/img/p1-12.jpg)\n\n## 总结\n\n以上，总结了我在实践中发现的优化效果较明显的三种方案。优化是无止境的，除了以上的方案以外还有很多地方值得研究。比如，css、js 压缩，小图片转 base64，第三方 UI 组件按需引入，利用 `prerender-spa-plugin` 插件实现预渲染等等。","tags":["Vue"]}]